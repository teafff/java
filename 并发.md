#### 程序计数器私有？

````
	程序计数器主要做两件事：
	1.字节码解释器通过改变程序计数器来读取指令，实现代码的流程控制；
	2.在多线程中，程序计数器主要记录当前线程的执行位置，保证线程被切换回来的时候能知道上次运行到什么位置了。
	所以程序计数器私有化主要是为了保证线程切换后能恢复到正常的执行位置。
````

#### 虚拟机栈和本地方法栈私有？

````
	虚拟机栈：存放的是栈帧。每个java方法在执行的时候会创建一个栈帧放入虚拟机栈中。这个栈帧中保存了局部变量表、操作数栈、常量池引用等信息。(局部变量表中放方法中的参数和变量，还有对象的引用)
	本地方法栈：和虚拟机栈作用相似。主要是存放native方法的数据。
	私有化是为了保证线程中的局部变量不会被其他线程访问。
````

#### 堆和方法区

```
	堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，主要用于存放新创建的对象实例，几乎所有对象都在这里分配内存。方法区是存放已经加载了的类信息、常量、静态变量等数据。
```

#### 使用多线程可能带来的问题：内存泄漏、死锁、线程不安全

```
	内存泄漏就是堆内存中一些不使用的对象，但是却无法被回收，这样就一直在内存中，最终导致内存泄露。
	例子：
		大量使用static、常量之类的；
		创建连接、打开流，结束后没有关闭；
	内存泄露检测：使用工具(Java VisualVM)
```

#### 死锁

```
死锁的必要条件：
	请求和保持；
	互斥；
	不可剥夺；
	循环等待；
预防死锁：
	破坏请求和保持条件：一次性申请所有需要的资源；
	破坏不可剥夺条件：如果申请不到资源，则主动释放；
	破坏循环等待条件：按顺序申请资源。

```

#### Synchronized关键字

```
	synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程在执行。早期的java版本中synchronized属于重量级锁，效率很低。
```

```
为什么早期效率低？
	因为早期技术不成熟，过于依赖操作系统底层的锁来实现。在切换线程时需要从用户态到内核态，这里需要较长的时间，所以效率低。
    在jdk1.6之后，对synchronized有了很大的优化，引入无锁、偏向锁、轻量锁、重量锁来对synchronized分级，大大提升效率。
```

```
synchronized用法：
	修饰实例方法：对当前对象实例加锁
	修饰静态方法(也就是修饰类)：对当前类加锁。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
	修饰代码块：给指定对象/类加锁
```

```
synchronized关键字的底层原理：
	修饰代码块：
		monitorenter和monitorexit来对同步代码块进行加锁。
	修饰方法：
		有一个ACC_SYNCHRONIZED标识，标识该方法为同步方法。
```

#### java的锁

```
乐观锁和悲观锁：
    对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。
    乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。实现乐观锁的类AtomicInteger。
    * 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
    * 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

自旋锁和适应性自旋锁：
    在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

无锁、偏向锁、轻量级锁、重量级锁：专门针对于synchronized。锁的状态只能升不能降。
    重量级锁：依赖于操作系统的Mutex Lock（互斥锁）来实现的锁。效率很低。JDK6之前synchronized的实现方式。

    无锁：没有对资源进行锁定，所有线程都能访问同一个资源，但是同时只有一个线程能修改成功。
    偏向锁：一段同步代码一直被一个线程所访问，则该线程会自动获取锁，降低锁的获取代价。
    轻量级锁：当锁是偏向锁的时候，如果被另外的线程所访问，则偏向锁升级为轻量级锁，其他线程通过自旋尝试获取锁。
    重量级锁：若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数或者一个线程持有锁，一个在自旋，又有第三个线程来访问时，轻量级锁升级为重量级锁。此时等待的线程都会进入阻塞状态。

公平锁和非公平锁：
    公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程可以获得锁。优点是等待锁的线程不会被饿死。缺点是整体吞吐效率比非公平锁要低，等待队列中除第一个线程外所有线程都会被阻塞。CPU唤醒阻塞线程开销比非公平锁大。
    非公平锁：多个线程加锁时直接尝试获取锁，获取不到才会加入等待队列。但如果此时锁刚好可用，则这个线程可以直接获取到锁。优点：减少唤起线程的开销，整体吞吐率高。缺点：等待队列中的线程可能会饿死，或者很久才会获得锁。

可重入锁和非可重入锁：
    可重入锁（递归锁）：同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。优点：一定程度可以避免死锁。
    非可重入锁：当前线程执行某个方法获取了锁，在这个方法中再次尝试获取锁时，会因为无法获取而阻塞。产生死锁。

独享锁和共享锁：都是悲观锁
    独享锁（排他锁）：该锁一次只能被一个线程所持有。如果一个线程对数据A加上排他锁，则其他线程无法对数据A加任何类型的锁。获得排他锁的线程可以读写数据。
    共享锁：该锁可以被多个线程所持有。如果线程T对数据A加上共享锁后，其他线程只能对数据A加共享锁，不能加排他锁。共享锁的线程只能读数据，无法修改数据。
```

#### Synchronized和ReentrantLock的区别

```
两者都是可重入锁；
synchronized是jvm自带的，而ReentrantLock实现了Lock接口，但是ReentrantLock需要lock和unlock来加锁解锁；
ReentrantLock比synchronized增加了更多的功能：
	等待可中断：可以让正在等待的线程放弃等待；
	可实现公平锁：ReentrantLock可以指定公平锁还是非公平锁；Synchronized只能是非公平锁；
	选择性通知：可以有选择性通知某些线程
```

#### Volatile

```
	如果主存中有一个共享变量，两个线程都去访问它，为了提高速度，线程一般把变量保存在本地内存中，这样就可能造成一个线程修改主存中的值，另外一个线程还没来得及去读取主存中的值的情况，造成数据不一致。
	因此使用volatile，每次都在主存中读取变量值，同时防止JVM的指令重排(双加锁的单例模式)。
```

#### 并发的三大特性

```
原子性：一系列操作要么全部执行，要么都不执行。synchronized可以保证。
可见性：一个线程对共享变量进行了修改，另外的线程可以立即看到最新修改的值。volatile、synchronized可以保证。
有序性：代码按顺序执行。volatile可以保证。
```

#### Synchronized和volatile的区别

````
volatile是线程同步的轻量级实现，性能比synchronized好；
volatile能保证可见性，但是不能保证数据的原子性；synchronized都可以保证；
volatile只能用于变量，synchronized可以修饰方法和代码块。
````

#### ThreadLocal

````
ThreadLocal让每个线程都有自己私有的数据。如果创建了一个ThreadLocal变量，则每一个访问这个变量的线程都会有该变量的副本。
````

```
ThreadLocal的底层：
	底层是ThreadLocalMap，是一个HashMap；
	可以调用get()方法：获取默认值；
	可以调用set()方法：将默认值修改为当前线程中副本的值。在ThreadLocalMap中存放key=当前线程，value=要设置的值
```

#### ThreadLocal内存泄漏的问题

```
ThreadLocalMap的key是弱引用，value是强引用。所以在垃圾回收的时候会出现key被清理而value还保留的情况。

强引用：垃圾回收不会回收的对象，比如new一个对象的引用。如果错误保持强引用会产生内存泄漏。
软引用：当内存不足时，回收软引用对象。
弱引用：进行垃圾回收就会回收弱引用对象。
虚引用：
```

#### 线程池

````
还没看
````

#### Atomic原子类

```
常说的JUC包：java.util.concurrent  这是java处理并发的包
```

```
JUC包中的4类原子类：
基本类型：AtomicInteger、AtomicLong、AtomicBoolean
数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
引用类型：AtomicReference、AtomicStampedReference、AtomicMarkableReference
对象的属性修改类型：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater

使用Atomic原子类，即使不加锁也能实现线程安全
```

#### AtomicInteger的原理

````
主要使用了CAS+volatile			Unsafe类
````

#### AQS

```
如果被请求的共享资源空闲，则将当前请求资源设置为有效工作线程，并将共享资源锁定。
如果被请求的共享资源已经被占用，则AQS设置了一个CLH队列，将暂时获取不到锁的线程加入到队列中。		队列基于FIFO
```

#### AQS对资源的共享方式

```
Exclusive(独占)：只有一个线程能执行。比如ReentrantLock。又分为公平锁和非公平锁。
Share(共享)：多个线程可以同时执行
```

